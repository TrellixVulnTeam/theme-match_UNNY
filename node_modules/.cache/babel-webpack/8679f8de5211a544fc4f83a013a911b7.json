{"ast":null,"code":"import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\n\nvar Component = function () {\n  /**\r\n   *\r\n   * @param name The public service name, e.g. app, auth, firestore, database\r\n   * @param instanceFactory Service factory responsible for creating the public interface\r\n   * @param type whether the service provided by the component is public or private\r\n   */\n  function Component(name, instanceFactory, type) {\n    this.name = name;\n    this.instanceFactory = instanceFactory;\n    this.type = type;\n    this.multipleInstances = false;\n    /**\r\n     * Properties to be added to the service namespace\r\n     */\n\n    this.serviceProps = {};\n    this.instantiationMode = \"LAZY\"\n    /* LAZY */\n    ;\n    this.onInstanceCreated = null;\n  }\n\n  Component.prototype.setInstantiationMode = function (mode) {\n    this.instantiationMode = mode;\n    return this;\n  };\n\n  Component.prototype.setMultipleInstances = function (multipleInstances) {\n    this.multipleInstances = multipleInstances;\n    return this;\n  };\n\n  Component.prototype.setServiceProps = function (props) {\n    this.serviceProps = props;\n    return this;\n  };\n\n  Component.prototype.setInstanceCreatedCallback = function (callback) {\n    this.onInstanceCreated = callback;\n    return this;\n  };\n\n  return Component;\n}();\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\n\nvar Provider = function () {\n  function Provider(name, container) {\n    this.name = name;\n    this.container = container;\n    this.component = null;\n    this.instances = new Map();\n    this.instancesDeferred = new Map();\n    this.instancesOptions = new Map();\n    this.onInitCallbacks = new Map();\n  }\n  /**\r\n   * @param identifier A provider can provide mulitple instances of a service\r\n   * if this.component.multipleInstances is true.\r\n   */\n\n\n  Provider.prototype.get = function (identifier) {\n    // if multipleInstances is not supported, use the default name\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n\n    if (!this.instancesDeferred.has(normalizedIdentifier)) {\n      var deferred = new Deferred();\n      this.instancesDeferred.set(normalizedIdentifier, deferred);\n\n      if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n        // initialize the service if it can be auto-initialized\n        try {\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n\n          if (instance) {\n            deferred.resolve(instance);\n          }\n        } catch (e) {// when the instance factory throws an exception during get(), it should not cause\n          // a fatal error. We just return the unresolved promise in this case.\n        }\n      }\n    }\n\n    return this.instancesDeferred.get(normalizedIdentifier).promise;\n  };\n\n  Provider.prototype.getImmediate = function (options) {\n    var _a; // if multipleInstances is not supported, use the default name\n\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\n    var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\n\n    if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {\n      try {\n        return this.getOrInitializeService({\n          instanceIdentifier: normalizedIdentifier\n        });\n      } catch (e) {\n        if (optional) {\n          return null;\n        } else {\n          throw e;\n        }\n      }\n    } else {\n      // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\n      if (optional) {\n        return null;\n      } else {\n        throw Error(\"Service \" + this.name + \" is not available\");\n      }\n    }\n  };\n\n  Provider.prototype.getComponent = function () {\n    return this.component;\n  };\n\n  Provider.prototype.setComponent = function (component) {\n    var e_1, _a;\n\n    if (component.name !== this.name) {\n      throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\n    }\n\n    if (this.component) {\n      throw Error(\"Component for \" + this.name + \" has already been provided\");\n    }\n\n    this.component = component; // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\n\n    if (!this.shouldAutoInitialize()) {\n      return;\n    } // if the service is eager, initialize the default instance\n\n\n    if (isComponentEager(component)) {\n      try {\n        this.getOrInitializeService({\n          instanceIdentifier: DEFAULT_ENTRY_NAME\n        });\n      } catch (e) {// when the instance factory for an eager Component throws an exception during the eager\n        // initialization, it should not cause a fatal error.\n        // TODO: Investigate if we need to make it configurable, because some component may want to cause\n        // a fatal error in this case?\n      }\n    }\n\n    try {\n      // Create service instances for the pending promises and resolve them\n      // NOTE: if this.multipleInstances is false, only the default instance will be created\n      // and all promises with resolve with it regardless of the identifier.\n      for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var _d = __read(_c.value, 2),\n            instanceIdentifier = _d[0],\n            instanceDeferred = _d[1];\n\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        try {\n          // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\n          var instance = this.getOrInitializeService({\n            instanceIdentifier: normalizedIdentifier\n          });\n          instanceDeferred.resolve(instance);\n        } catch (e) {// when the instance factory throws an exception, it should not cause\n          // a fatal error. We just leave the promise unresolved.\n        }\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  };\n\n  Provider.prototype.clearInstance = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    this.instancesDeferred.delete(identifier);\n    this.instancesOptions.delete(identifier);\n    this.instances.delete(identifier);\n  }; // app.delete() will call this method on every provider to delete the services\n  // TODO: should we mark the provider as deleted?\n\n\n  Provider.prototype.delete = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var services;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            services = Array.from(this.instances.values());\n            return [4\n            /*yield*/\n            , Promise.all(__spreadArray(__spreadArray([], __read(services.filter(function (service) {\n              return 'INTERNAL' in service;\n            }) // legacy services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service.INTERNAL.delete();\n            }))), __read(services.filter(function (service) {\n              return '_delete' in service;\n            }) // modularized services\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .map(function (service) {\n              return service._delete();\n            }))))];\n\n          case 1:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Provider.prototype.isComponentSet = function () {\n    return this.component != null;\n  };\n\n  Provider.prototype.isInitialized = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    return this.instances.has(identifier);\n  };\n\n  Provider.prototype.getOptions = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    return this.instancesOptions.get(identifier) || {};\n  };\n\n  Provider.prototype.initialize = function (opts) {\n    var e_2, _a;\n\n    if (opts === void 0) {\n      opts = {};\n    }\n\n    var _b = opts.options,\n        options = _b === void 0 ? {} : _b;\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\n\n    if (this.isInitialized(normalizedIdentifier)) {\n      throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\n    }\n\n    if (!this.isComponentSet()) {\n      throw Error(\"Component \" + this.name + \" has not been registered yet\");\n    }\n\n    var instance = this.getOrInitializeService({\n      instanceIdentifier: normalizedIdentifier,\n      options: options\n    });\n\n    try {\n      // resolve any pending promise waiting for the service instance\n      for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\n        var _e = __read(_d.value, 2),\n            instanceIdentifier = _e[0],\n            instanceDeferred = _e[1];\n\n        var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\n\n        if (normalizedIdentifier === normalizedDeferredIdentifier) {\n          instanceDeferred.resolve(instance);\n        }\n      }\n    } catch (e_2_1) {\n      e_2 = {\n        error: e_2_1\n      };\n    } finally {\n      try {\n        if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n      } finally {\n        if (e_2) throw e_2.error;\n      }\n    }\n\n    return instance;\n  };\n  /**\r\n   *\r\n   * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n   * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n   *\r\n   * @param identifier An optional instance identifier\r\n   * @returns a function to unregister the callback\r\n   */\n\n\n  Provider.prototype.onInit = function (callback, identifier) {\n    var _a;\n\n    var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\n    var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\n    existingCallbacks.add(callback);\n    this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\n    var existingInstance = this.instances.get(normalizedIdentifier);\n\n    if (existingInstance) {\n      callback(existingInstance, normalizedIdentifier);\n    }\n\n    return function () {\n      existingCallbacks.delete(callback);\n    };\n  };\n  /**\r\n   * Invoke onInit callbacks synchronously\r\n   * @param instance the service instance`\r\n   */\n\n\n  Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\n    var e_3, _a;\n\n    var callbacks = this.onInitCallbacks.get(identifier);\n\n    if (!callbacks) {\n      return;\n    }\n\n    try {\n      for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\n        var callback = callbacks_1_1.value;\n\n        try {\n          callback(instance, identifier);\n        } catch (_b) {// ignore errors in the onInit callback\n        }\n      }\n    } catch (e_3_1) {\n      e_3 = {\n        error: e_3_1\n      };\n    } finally {\n      try {\n        if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\n      } finally {\n        if (e_3) throw e_3.error;\n      }\n    }\n  };\n\n  Provider.prototype.getOrInitializeService = function (_a) {\n    var instanceIdentifier = _a.instanceIdentifier,\n        _b = _a.options,\n        options = _b === void 0 ? {} : _b;\n    var instance = this.instances.get(instanceIdentifier);\n\n    if (!instance && this.component) {\n      instance = this.component.instanceFactory(this.container, {\n        instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\n        options: options\n      });\n      this.instances.set(instanceIdentifier, instance);\n      this.instancesOptions.set(instanceIdentifier, options);\n      /**\r\n       * Invoke onInit listeners.\r\n       * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n       * while onInit listeners are registered by consumers of the provider.\r\n       */\n\n      this.invokeOnInitCallbacks(instance, instanceIdentifier);\n      /**\r\n       * Order is important\r\n       * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n       * makes `isInitialized()` return true.\r\n       */\n\n      if (this.component.onInstanceCreated) {\n        try {\n          this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\n        } catch (_c) {// ignore errors in the onInstanceCreatedCallback\n        }\n      }\n    }\n\n    return instance || null;\n  };\n\n  Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\n    if (identifier === void 0) {\n      identifier = DEFAULT_ENTRY_NAME;\n    }\n\n    if (this.component) {\n      return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\n    } else {\n      return identifier; // assume multiple instances are supported before the component is provided.\n    }\n  };\n\n  Provider.prototype.shouldAutoInitialize = function () {\n    return !!this.component && this.component.instantiationMode !== \"EXPLICIT\"\n    /* EXPLICIT */\n    ;\n  };\n\n  return Provider;\n}(); // undefined should be passed to the service factory for the default instance\n\n\nfunction normalizeIdentifierForFactory(identifier) {\n  return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\n}\n\nfunction isComponentEager(component) {\n  return component.instantiationMode === \"EAGER\"\n  /* EAGER */\n  ;\n}\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\n\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\n\n\nvar ComponentContainer = function () {\n  function ComponentContainer(name) {\n    this.name = name;\n    this.providers = new Map();\n  }\n  /**\r\n   *\r\n   * @param component Component being added\r\n   * @param overwrite When a component with the same name has already been registered,\r\n   * if overwrite is true: overwrite the existing component with the new component and create a new\r\n   * provider with the new component. It can be useful in tests where you want to use different mocks\r\n   * for different tests.\r\n   * if overwrite is false: throw an exception\r\n   */\n\n\n  ComponentContainer.prototype.addComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\n    }\n\n    provider.setComponent(component);\n  };\n\n  ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\n    var provider = this.getProvider(component.name);\n\n    if (provider.isComponentSet()) {\n      // delete the existing provider from the container, so we can register the new component\n      this.providers.delete(component.name);\n    }\n\n    this.addComponent(component);\n  };\n  /**\r\n   * getProvider provides a type safe interface where it can only be called with a field name\r\n   * present in NameServiceMapping interface.\r\n   *\r\n   * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n   * themselves.\r\n   */\n\n\n  ComponentContainer.prototype.getProvider = function (name) {\n    if (this.providers.has(name)) {\n      return this.providers.get(name);\n    } // create a Provider for a service that hasn't registered with Firebase\n\n\n    var provider = new Provider(name, this);\n    this.providers.set(name, provider);\n    return provider;\n  };\n\n  ComponentContainer.prototype.getProviders = function () {\n    return Array.from(this.providers.values());\n  };\n\n  return ComponentContainer;\n}();\n\nexport { Component, ComponentContainer, Provider }; //# sourceMappingURL=index.esm.js.map","map":{"version":3,"sources":["/home/alicia/dev/angular/theme-picker/node_modules/@firebase/component/dist/index.esm.js"],"names":["__values","__read","__awaiter","__generator","__spreadArray","Deferred","Component","name","instanceFactory","type","multipleInstances","serviceProps","instantiationMode","onInstanceCreated","prototype","setInstantiationMode","mode","setMultipleInstances","setServiceProps","props","setInstanceCreatedCallback","callback","DEFAULT_ENTRY_NAME","Provider","container","component","instances","Map","instancesDeferred","instancesOptions","onInitCallbacks","get","identifier","normalizedIdentifier","normalizeInstanceIdentifier","has","deferred","set","isInitialized","shouldAutoInitialize","instance","getOrInitializeService","instanceIdentifier","resolve","e","promise","getImmediate","options","_a","optional","Error","getComponent","setComponent","e_1","isComponentEager","_b","entries","_c","next","done","_d","value","instanceDeferred","e_1_1","error","return","call","clearInstance","delete","services","label","Array","from","values","Promise","all","filter","service","map","INTERNAL","_delete","sent","isComponentSet","getOptions","initialize","opts","e_2","_e","normalizedDeferredIdentifier","e_2_1","onInit","existingCallbacks","Set","add","existingInstance","invokeOnInitCallbacks","e_3","callbacks","callbacks_1","callbacks_1_1","e_3_1","normalizeIdentifierForFactory","undefined","ComponentContainer","providers","addComponent","provider","getProvider","addOrOverwriteComponent","getProviders"],"mappings":"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","sourcesContent":["import { __values, __read, __awaiter, __generator, __spreadArray } from 'tslib';\nimport { Deferred } from '@firebase/util';\n\n/**\r\n * Component for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar Component = /** @class */ (function () {\r\n    /**\r\n     *\r\n     * @param name The public service name, e.g. app, auth, firestore, database\r\n     * @param instanceFactory Service factory responsible for creating the public interface\r\n     * @param type whether the service provided by the component is public or private\r\n     */\r\n    function Component(name, instanceFactory, type) {\r\n        this.name = name;\r\n        this.instanceFactory = instanceFactory;\r\n        this.type = type;\r\n        this.multipleInstances = false;\r\n        /**\r\n         * Properties to be added to the service namespace\r\n         */\r\n        this.serviceProps = {};\r\n        this.instantiationMode = \"LAZY\" /* LAZY */;\r\n        this.onInstanceCreated = null;\r\n    }\r\n    Component.prototype.setInstantiationMode = function (mode) {\r\n        this.instantiationMode = mode;\r\n        return this;\r\n    };\r\n    Component.prototype.setMultipleInstances = function (multipleInstances) {\r\n        this.multipleInstances = multipleInstances;\r\n        return this;\r\n    };\r\n    Component.prototype.setServiceProps = function (props) {\r\n        this.serviceProps = props;\r\n        return this;\r\n    };\r\n    Component.prototype.setInstanceCreatedCallback = function (callback) {\r\n        this.onInstanceCreated = callback;\r\n        return this;\r\n    };\r\n    return Component;\r\n}());\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\nvar DEFAULT_ENTRY_NAME = '[DEFAULT]';\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * Provider for instance for service name T, e.g. 'auth', 'auth-internal'\r\n * NameServiceMapping[T] is an alias for the type of the instance\r\n */\r\nvar Provider = /** @class */ (function () {\r\n    function Provider(name, container) {\r\n        this.name = name;\r\n        this.container = container;\r\n        this.component = null;\r\n        this.instances = new Map();\r\n        this.instancesDeferred = new Map();\r\n        this.instancesOptions = new Map();\r\n        this.onInitCallbacks = new Map();\r\n    }\r\n    /**\r\n     * @param identifier A provider can provide mulitple instances of a service\r\n     * if this.component.multipleInstances is true.\r\n     */\r\n    Provider.prototype.get = function (identifier) {\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        if (!this.instancesDeferred.has(normalizedIdentifier)) {\r\n            var deferred = new Deferred();\r\n            this.instancesDeferred.set(normalizedIdentifier, deferred);\r\n            if (this.isInitialized(normalizedIdentifier) ||\r\n                this.shouldAutoInitialize()) {\r\n                // initialize the service if it can be auto-initialized\r\n                try {\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    if (instance) {\r\n                        deferred.resolve(instance);\r\n                    }\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception during get(), it should not cause\r\n                    // a fatal error. We just return the unresolved promise in this case.\r\n                }\r\n            }\r\n        }\r\n        return this.instancesDeferred.get(normalizedIdentifier).promise;\r\n    };\r\n    Provider.prototype.getImmediate = function (options) {\r\n        var _a;\r\n        // if multipleInstances is not supported, use the default name\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);\r\n        var optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;\r\n        if (this.isInitialized(normalizedIdentifier) ||\r\n            this.shouldAutoInitialize()) {\r\n            try {\r\n                return this.getOrInitializeService({\r\n                    instanceIdentifier: normalizedIdentifier\r\n                });\r\n            }\r\n            catch (e) {\r\n                if (optional) {\r\n                    return null;\r\n                }\r\n                else {\r\n                    throw e;\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // In case a component is not initialized and should/can not be auto-initialized at the moment, return null if the optional flag is set, or throw\r\n            if (optional) {\r\n                return null;\r\n            }\r\n            else {\r\n                throw Error(\"Service \" + this.name + \" is not available\");\r\n            }\r\n        }\r\n    };\r\n    Provider.prototype.getComponent = function () {\r\n        return this.component;\r\n    };\r\n    Provider.prototype.setComponent = function (component) {\r\n        var e_1, _a;\r\n        if (component.name !== this.name) {\r\n            throw Error(\"Mismatching Component \" + component.name + \" for Provider \" + this.name + \".\");\r\n        }\r\n        if (this.component) {\r\n            throw Error(\"Component for \" + this.name + \" has already been provided\");\r\n        }\r\n        this.component = component;\r\n        // return early without attempting to initialize the component if the component requires explicit initialization (calling `Provider.initialize()`)\r\n        if (!this.shouldAutoInitialize()) {\r\n            return;\r\n        }\r\n        // if the service is eager, initialize the default instance\r\n        if (isComponentEager(component)) {\r\n            try {\r\n                this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });\r\n            }\r\n            catch (e) {\r\n                // when the instance factory for an eager Component throws an exception during the eager\r\n                // initialization, it should not cause a fatal error.\r\n                // TODO: Investigate if we need to make it configurable, because some component may want to cause\r\n                // a fatal error in this case?\r\n            }\r\n        }\r\n        try {\r\n            // Create service instances for the pending promises and resolve them\r\n            // NOTE: if this.multipleInstances is false, only the default instance will be created\r\n            // and all promises with resolve with it regardless of the identifier.\r\n            for (var _b = __values(this.instancesDeferred.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {\r\n                var _d = __read(_c.value, 2), instanceIdentifier = _d[0], instanceDeferred = _d[1];\r\n                var normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                try {\r\n                    // `getOrInitializeService()` should always return a valid instance since a component is guaranteed. use ! to make typescript happy.\r\n                    var instance = this.getOrInitializeService({\r\n                        instanceIdentifier: normalizedIdentifier\r\n                    });\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n                catch (e) {\r\n                    // when the instance factory throws an exception, it should not cause\r\n                    // a fatal error. We just leave the promise unresolved.\r\n                }\r\n            }\r\n        }\r\n        catch (e_1_1) { e_1 = { error: e_1_1 }; }\r\n        finally {\r\n            try {\r\n                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\r\n            }\r\n            finally { if (e_1) throw e_1.error; }\r\n        }\r\n    };\r\n    Provider.prototype.clearInstance = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        this.instancesDeferred.delete(identifier);\r\n        this.instancesOptions.delete(identifier);\r\n        this.instances.delete(identifier);\r\n    };\r\n    // app.delete() will call this method on every provider to delete the services\r\n    // TODO: should we mark the provider as deleted?\r\n    Provider.prototype.delete = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var services;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        services = Array.from(this.instances.values());\r\n                        return [4 /*yield*/, Promise.all(__spreadArray(__spreadArray([], __read(services\r\n                                .filter(function (service) { return 'INTERNAL' in service; }) // legacy services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service.INTERNAL.delete(); }))), __read(services\r\n                                .filter(function (service) { return '_delete' in service; }) // modularized services\r\n                                // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n                                .map(function (service) { return service._delete(); }))))];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    Provider.prototype.isComponentSet = function () {\r\n        return this.component != null;\r\n    };\r\n    Provider.prototype.isInitialized = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instances.has(identifier);\r\n    };\r\n    Provider.prototype.getOptions = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        return this.instancesOptions.get(identifier) || {};\r\n    };\r\n    Provider.prototype.initialize = function (opts) {\r\n        var e_2, _a;\r\n        if (opts === void 0) { opts = {}; }\r\n        var _b = opts.options, options = _b === void 0 ? {} : _b;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);\r\n        if (this.isInitialized(normalizedIdentifier)) {\r\n            throw Error(this.name + \"(\" + normalizedIdentifier + \") has already been initialized\");\r\n        }\r\n        if (!this.isComponentSet()) {\r\n            throw Error(\"Component \" + this.name + \" has not been registered yet\");\r\n        }\r\n        var instance = this.getOrInitializeService({\r\n            instanceIdentifier: normalizedIdentifier,\r\n            options: options\r\n        });\r\n        try {\r\n            // resolve any pending promise waiting for the service instance\r\n            for (var _c = __values(this.instancesDeferred.entries()), _d = _c.next(); !_d.done; _d = _c.next()) {\r\n                var _e = __read(_d.value, 2), instanceIdentifier = _e[0], instanceDeferred = _e[1];\r\n                var normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);\r\n                if (normalizedIdentifier === normalizedDeferredIdentifier) {\r\n                    instanceDeferred.resolve(instance);\r\n                }\r\n            }\r\n        }\r\n        catch (e_2_1) { e_2 = { error: e_2_1 }; }\r\n        finally {\r\n            try {\r\n                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\r\n            }\r\n            finally { if (e_2) throw e_2.error; }\r\n        }\r\n        return instance;\r\n    };\r\n    /**\r\n     *\r\n     * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().\r\n     * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.\r\n     *\r\n     * @param identifier An optional instance identifier\r\n     * @returns a function to unregister the callback\r\n     */\r\n    Provider.prototype.onInit = function (callback, identifier) {\r\n        var _a;\r\n        var normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);\r\n        var existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : new Set();\r\n        existingCallbacks.add(callback);\r\n        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);\r\n        var existingInstance = this.instances.get(normalizedIdentifier);\r\n        if (existingInstance) {\r\n            callback(existingInstance, normalizedIdentifier);\r\n        }\r\n        return function () {\r\n            existingCallbacks.delete(callback);\r\n        };\r\n    };\r\n    /**\r\n     * Invoke onInit callbacks synchronously\r\n     * @param instance the service instance`\r\n     */\r\n    Provider.prototype.invokeOnInitCallbacks = function (instance, identifier) {\r\n        var e_3, _a;\r\n        var callbacks = this.onInitCallbacks.get(identifier);\r\n        if (!callbacks) {\r\n            return;\r\n        }\r\n        try {\r\n            for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {\r\n                var callback = callbacks_1_1.value;\r\n                try {\r\n                    callback(instance, identifier);\r\n                }\r\n                catch (_b) {\r\n                    // ignore errors in the onInit callback\r\n                }\r\n            }\r\n        }\r\n        catch (e_3_1) { e_3 = { error: e_3_1 }; }\r\n        finally {\r\n            try {\r\n                if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);\r\n            }\r\n            finally { if (e_3) throw e_3.error; }\r\n        }\r\n    };\r\n    Provider.prototype.getOrInitializeService = function (_a) {\r\n        var instanceIdentifier = _a.instanceIdentifier, _b = _a.options, options = _b === void 0 ? {} : _b;\r\n        var instance = this.instances.get(instanceIdentifier);\r\n        if (!instance && this.component) {\r\n            instance = this.component.instanceFactory(this.container, {\r\n                instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),\r\n                options: options\r\n            });\r\n            this.instances.set(instanceIdentifier, instance);\r\n            this.instancesOptions.set(instanceIdentifier, options);\r\n            /**\r\n             * Invoke onInit listeners.\r\n             * Note this.component.onInstanceCreated is different, which is used by the component creator,\r\n             * while onInit listeners are registered by consumers of the provider.\r\n             */\r\n            this.invokeOnInitCallbacks(instance, instanceIdentifier);\r\n            /**\r\n             * Order is important\r\n             * onInstanceCreated() should be called after this.instances.set(instanceIdentifier, instance); which\r\n             * makes `isInitialized()` return true.\r\n             */\r\n            if (this.component.onInstanceCreated) {\r\n                try {\r\n                    this.component.onInstanceCreated(this.container, instanceIdentifier, instance);\r\n                }\r\n                catch (_c) {\r\n                    // ignore errors in the onInstanceCreatedCallback\r\n                }\r\n            }\r\n        }\r\n        return instance || null;\r\n    };\r\n    Provider.prototype.normalizeInstanceIdentifier = function (identifier) {\r\n        if (identifier === void 0) { identifier = DEFAULT_ENTRY_NAME; }\r\n        if (this.component) {\r\n            return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;\r\n        }\r\n        else {\r\n            return identifier; // assume multiple instances are supported before the component is provided.\r\n        }\r\n    };\r\n    Provider.prototype.shouldAutoInitialize = function () {\r\n        return (!!this.component &&\r\n            this.component.instantiationMode !== \"EXPLICIT\" /* EXPLICIT */);\r\n    };\r\n    return Provider;\r\n}());\r\n// undefined should be passed to the service factory for the default instance\r\nfunction normalizeIdentifierForFactory(identifier) {\r\n    return identifier === DEFAULT_ENTRY_NAME ? undefined : identifier;\r\n}\r\nfunction isComponentEager(component) {\r\n    return component.instantiationMode === \"EAGER\" /* EAGER */;\r\n}\n\n/**\r\n * @license\r\n * Copyright 2019 Google LLC\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *   http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/**\r\n * ComponentContainer that provides Providers for service name T, e.g. `auth`, `auth-internal`\r\n */\r\nvar ComponentContainer = /** @class */ (function () {\r\n    function ComponentContainer(name) {\r\n        this.name = name;\r\n        this.providers = new Map();\r\n    }\r\n    /**\r\n     *\r\n     * @param component Component being added\r\n     * @param overwrite When a component with the same name has already been registered,\r\n     * if overwrite is true: overwrite the existing component with the new component and create a new\r\n     * provider with the new component. It can be useful in tests where you want to use different mocks\r\n     * for different tests.\r\n     * if overwrite is false: throw an exception\r\n     */\r\n    ComponentContainer.prototype.addComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            throw new Error(\"Component \" + component.name + \" has already been registered with \" + this.name);\r\n        }\r\n        provider.setComponent(component);\r\n    };\r\n    ComponentContainer.prototype.addOrOverwriteComponent = function (component) {\r\n        var provider = this.getProvider(component.name);\r\n        if (provider.isComponentSet()) {\r\n            // delete the existing provider from the container, so we can register the new component\r\n            this.providers.delete(component.name);\r\n        }\r\n        this.addComponent(component);\r\n    };\r\n    /**\r\n     * getProvider provides a type safe interface where it can only be called with a field name\r\n     * present in NameServiceMapping interface.\r\n     *\r\n     * Firebase SDKs providing services should extend NameServiceMapping interface to register\r\n     * themselves.\r\n     */\r\n    ComponentContainer.prototype.getProvider = function (name) {\r\n        if (this.providers.has(name)) {\r\n            return this.providers.get(name);\r\n        }\r\n        // create a Provider for a service that hasn't registered with Firebase\r\n        var provider = new Provider(name, this);\r\n        this.providers.set(name, provider);\r\n        return provider;\r\n    };\r\n    ComponentContainer.prototype.getProviders = function () {\r\n        return Array.from(this.providers.values());\r\n    };\r\n    return ComponentContainer;\r\n}());\n\nexport { Component, ComponentContainer, Provider };\n//# sourceMappingURL=index.esm.js.map\n"]},"metadata":{},"sourceType":"module"}